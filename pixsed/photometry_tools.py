import numpy as np
import matplotlib.pyplot as plt
from astropy.wcs import WCS
from astropy.stats import sigma_clipped_stats, mad_std
from astropy.convolution import convolve
from photutils.isophote import Ellipse, build_ellipse_model
from photutils.segmentation import detect_sources, make_2dgaussian_kernel, deblend_sources, SourceCatalog

from .utils import read_coordinate, plot_image

import matplotlib as mpl
mpl.rc("xtick", direction="in", labelsize=16)
mpl.rc("ytick", direction="in", labelsize=16)
mpl.rc("xtick.major", width=1., size=8)
mpl.rc("ytick.major", width=1., size=8)
mpl.rc("xtick.minor", width=1., size=5)
mpl.rc("ytick.minor", width=1., size=5)


class Image(object):
    '''
    The class of an image. For the moment, we only assume that there is one 
    science target in the image.
    '''
    def __init__(self, data, header, wcs=None, target_coordinate=None):
        '''
        Parameters
        ----------
        data : numpy 2D array
            The 2D image data.
        hearder : astropy fits header
            The header of the image data.
        '''
        self._data_org = data
        self._data = data.copy()
        self._header = header
        self._shape = data.shape

        self.get_wcs(wcs)

        if target_coordinate is not None:
            self._ra, self._dec = target_coordinate
            self._coord = read_coordinate(self._ra, self._dec)
            ra_pix, dec_pix = self.coord_world_to_pixel(self._coord)
            self._coord_pix = (float(ra_pix), float(dec_pix))
        else:
            self._ra, self._dec, self._coord = None, None, None


    def background_model(self):
        '''
        Generate the background model.
        '''
        self._background = None
    

    def background_properties(self, mask_type='quick', sigma=3, maxiters=5, **kwargs):
        '''
        Calculate the mean, median, and std of the background using sigma clip.

        Parameters
        ----------
        mask_type : string (default: 'quick')
            If 'quick', directly use the sigma clip to get a quick statistics. 
            If 'segmentation', use the mask generated by image segmentation to mask the source 
            emssion. This is a quick method, so the function will 
            continue even if the mask is None. 
            If 'full', use the carefully generated masks of the target and 
            background. The masks must be generated in advance.
        sigma : float (default: 3)
            Sigma clip threshold.
        maxiters : int (default: 5)
            Maximum iterations of the sigma clip.
        **kwargs : Other parameters of sigma_clipped_stats()

        Returns
        -------
        mean, median, stddev : floats
            The returns of sigma_clipped_stats().
        '''
        if mask_type == 'quick':
            mask = None
        elif mask_type == 'segmentation':
            if not hasattr(self, '_mask_segmentation'):
                raise ValueError('The background mask (_mask_segmentation) is not generated! Please run mask_segmentation()!')
            else:
                mask = self._mask_segmentation
        else:
            if not hasattr(self, '_mask_background'):
                raise ValueError('The background mask (_mask_background) is not generated! Please run mask_background()!')

            if not hasattr(self, '_mask_target'):
                raise ValueError('The target mask (_mask_target) is not generated! Please run mask_target()!')

            mask = self._mask_background & self._mask_target

        res = sigma_clipped_stats(self._data, mask=mask, sigma=sigma, maxiters=maxiters, **kwargs)
        self._bkg_mean, self._bkg_median, self._bkg_std = res
        return self._bkg_mean, self._bkg_median, self._bkg_std


    def background_subtract(self, method='median'):
        '''
        Remove the background of the image data.
        '''
        if method == 'median':
            assert hasattr(self, '_bkg_median'), 'Please run background_properties() first!'
            self._data -= self._bkg_median
        else:
            assert hasattr(self, '_background'), 'Please run background_model() first!'
            self._data -= self._background


    def coord_world_to_pixel(self, *args, **kwargs):
        """
        Convert the wcs to pixel coordinates.
        """
        assert not self._wcs is None
        return self._wcs.world_to_pixel(*args, **kwargs)


    def coord_pixel_to_world(self, *args, **kwargs):
        """
        Convert the pixel to wcs coordinates.
        """
        assert not self._wcs is None
        return self._wcs.pixel_to_world(*args, **kwargs)


    def detect_daofinder(self):
        '''
        Detect the source
        '''
        self._sources_daofinder = None


    def detect_segmentation(self, threshold, fwhm=3, size=5, npixels=10, 
                            deblend=False, nlevels=32, contrast=0.001,
                            progress_bar=False):
        '''
        Detect the source with image segmentation.

        Parameters
        ----------
        threshold : float
            The threshold of the source detection.
        fwhm : float (default: 3)
            The FWHM of the Gaussian kernel.
        size : int (default: 5)
            The kernel size.
        npixel : int (default: 10)
            The number of pixels.
        '''
        kernel = make_2dgaussian_kernel(fwhm=fwhm, size=size)  # FWHM = 3.0
        convolved_data = convolve(self._data, kernel)
        segment_map = detect_sources(convolved_data, threshold, npixels=npixels)

        if deblend:
            self._segmentation = deblend_sources(convolved_data, segment_map, npixels=npixels, 
                                                 nlevels=nlevels, contrast=contrast, progress_bar=progress_bar)
        else:
            self._segmentation = segment_map

        self._sources_segmentation = SourceCatalog(self._data, self._segmentation, convolved_data=convolved_data)


    def get_source_list(self, method='daofinder'):
        '''
        Get the source coordinate list.

        Parameters
        ----------
        method : string (default: 'daofinder')
            Select the detection method.
        '''
        self._source_list = None
    

    def get_source_extend(self):
        '''
        Get the extend source list to be masked.
        '''
        self._source_extend = None
    

    def get_source_point(self):
        '''
        Get the point source list to be masked.
        '''
        self._source_point = None


    def get_wcs(self, wcs=None):
        '''
        Get the WCS information.

        Parameters
        ----------
        wcs : WCS or HEADER
            The wcs information.
        '''
        if wcs is None:
            self._wcs = WCS(self._header)
        else:
            self._wcs = wcs


    def get_isophote(self, plot=False):
        '''
        Fit the isophote of the target and generate the ellipse model.
        (May include more complicated functions.)

        Parameters
        ----------
        plot : bool (default: False)
            Plot the isophote fitting results.
        '''
        self._isolist = None
        self._ellipse_model = None


    def get_psf(self, plot=False):
        '''
        Get the PSF model. (May include other properties of the PSF.)
        
        Parameters
        ----------
        plot : bool (default: False)
            Plot the information to show the psf building procedure.
        '''
        self._psf = None  # PSF image
        self._psf_FWHM = None  # PSF FWHM


    def get_radial_profile(self, plot=False):
        '''
        Get the radial surface bright profile of the target.

        Parameters
        ----------
        plot : bool (default: False)
            Plot the radial profile.
        '''
        self._rp = None

        if plot:
            self._rp.plot()


    def mask_background(self):
        '''
        Get the mask of the background. (Final method)
        '''
        mask_point = self.mask_background_point()
        mask_extend = self.mask_background_extend()
        self._mask_background = mask_point & mask_extend
    

    def mask_background_extend(self):
        '''
        Get the mask of the background extend sources.
        '''
        return 


    def mask_background_point(self):
        '''
        Get the mask of the background point sources.
        '''
        return 


    def mask_background_simple(self):
        '''
        Get the mask of the background sources with the current simple mehtod.
        '''
        self._mask_background = None


    def mask_segmentation(self, kernel_fwhm=None, kernel_size=5):
        '''
        Get the source mask directly from the image segmentation.
        '''
        mask = self._segmentation.data > 0

        if kernel_fwhm is None:
            self._mask_segmentation = mask
        else:
            kernel_size = max([kernel_size, 2*kernel_fwhm+1])
            kernel = make_2dgaussian_kernel(fwhm=kernel_fwhm, size=kernel_size)
            self._mask_segmentation = convolve(mask, kernel) > 0.1


    def mask_target_isophote(self):
        '''
        Get the mask of the target based on the source isophote.
        '''
        self._mask_target = None


    def mask_target_simple(self):
        '''
        Get the mask of the target with the current simple method.
        '''
        self._mask_target = None


    def plot_data(self, ax=None, percentile=99.5, vmin=None, vmax=None, stretch=None,
                  origin='lower', cmap='gray_r', show_target=True, **kwargs):
        """
        Plot the image data.

        Parameters
        ----------
        ax : Figure axis
            The axis handle of the figure.
        vmin : float
            The minimum scale of the image.
        vmax : float
            The maximum scale of the image.
        stretch : stretch object
            The stretch used to normalize the image color scale.
        origin : string (default: 'lower')
            The origin of the image.
        cmap : string (default: 'gray_r')
            The colormap.
        show_target : bool (default: True)
            Mark the target position if True.
        **kwargs : float
            The parameters of imshow() except the image and norm.

        Returns
        -------
        ax : Figure axis
            The handle of the image axis.

        Notes
        -----
        None.
        """
        ax = plot_image(self._data, ax=ax, percentile=percentile, vmin=vmin, vmax=vmax, stretch=stretch,
                        origin=origin, cmap=cmap, **kwargs)
        
        if show_target:
            ax.plot(self._coord_pix[0], self._coord_pix[1], marker='+', color='r', ms=10)
        return ax


    def plot_segmentation(self, ax=None):
        '''
        Plot the segmentation.
        '''
        if ax is None:
            fig, ax = plt.subplots(figsize=(7, 7))
        
        ax.imshow(self._segmentation, origin='lower', cmap=self._segmentation.cmap)
        return ax


    def remove_sources(self):
        '''
        Remove the contaminating sources in the image.
        '''
        self._image_cleaned = None


class Atlas(object):
    '''
    An atlas of images. Again, for the moment, we assume that there is only one 
    science target in each image.
    '''
    def __init__(self, image_list):
        '''
        Parameters
        ----------
        image_list : list
            A list of Images
        '''
        self._image_list = image_list

    def match_images(self):
        '''
        Get a new list of images with matched resolution, pixel scale, and size.
        '''
        self._image_list_mathced = None

    def __getitem__(self, items):
        '''
        Get the image object.
        '''
        if self._image_list_mathced is not None:
            return self._image_list_mathced[items]
        else:
            return self._image_list[items]

